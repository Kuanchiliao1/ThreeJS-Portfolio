{"version":3,"file":"index.58a04716.js","sources":["../../../../pages/index.vue"],"sourcesContent":["<template>\n  <div\n    id=\"container--intro\"\n    class=\"absolute text-white text-center center-Y center-X\"\n  >\n    <h1\n      id=\"tony-liao\"\n      class=\"translate-Y-down opacity-0 text-xl font-mono uppercase tracking-wide\"\n    >\n      Tony Liao\n    </h1>\n    <p\n      id=\"portfolio-description\"\n      class=\"translate-Y-down opacity-0 text-4xl font-exo\"\n    >\n      FRONTEND DEVELOPER AND EXPERIMENTER AT HEART\n    </p>\n    <a\n      id=\"my-work-btn\"\n      class=\"translate-Y-down opacity-0 inline-block mt-8 border px-4 py-2 rounded-lg text-sm font-mono hover:bg-white hover:text-grey-800\"\n      >View My Work</a\n    >\n  </div>\n</template>\n\n<script>\n// // Import statments must be OUTSIDE the script tag!\n// import gsap from \"gsap\";\n// const three = require('three');\n// import {\n//   PlaneGeometry,\n//   BufferAttribute,\n//   Raycaster,\n//   Scene,\n//   PerspectiveCamera,\n//   WebGLRenderer,\n//   BoxGeometry,\n//   MeshBasicMaterial,\n//   Mesh,\n//   PlaneGeometry,\n//   MeshPhongMaterial,\n//   DoubleSide,\n//   DirectionalLight,\n//   BufferGeometry,\n//   PointsMaterial,\n//   Float32BufferAttribute,\n//   Points,\n// } from \"three\";\n// // For using GUI to modify any values instead of using code\n// // const dat.gui = require('dat.gui');\n// // import * as dat from \"dat.gui\";\n// import OrbitControls from 'orbit-controls-es6';\n\nexport default {\n  // mounted() {\n  //   const gui = new dat.GUI();\n  //   // For adding the properties we want in the GUI\n  //   const world = {\n  //     plane: {\n  //       width: 400,\n  //       height: 400,\n  //       widthSegments: 50,\n  //       heightSegments: 50,\n  //     },\n  //   };\n\n  //   gui\n  //     .add(world.plane, \"width\", 1, 500)\n  //     // Invoke a function whenever the value of slider changes\n  //     .onChange(generatePlane);\n\n  //   gui\n  //     .add(world.plane, \"height\", 1, 500)\n  //     // Invoke a function whenever the value of slider changes\n  //     .onChange(generatePlane);\n\n  //   gui\n  //     .add(world.plane, \"widthSegments\", 1, 100)\n  //     // Invoke a function whenever the value of slider changes\n  //     .onChange(generatePlane);\n\n  //   gui\n  //     .add(world.plane, \"heightSegments\", 1, 100)\n  //     // Invoke a function whenever the value of slider changes\n  //     .onChange(generatePlane);\n\n  //   function generatePlane() {\n  //     planeMesh.geometry.dispose();\n  //     planeMesh.geometry = new PlaneGeometry(\n  //       world.plane.width,\n  //       world.plane.height,\n  //       world.plane.widthSegments,\n  //       world.plane.widthSegments\n  //     );\n\n  //     // Randomize vertices\n  //     const { array } = planeMesh.geometry.attributes.position;\n  //     const randomValues = [];\n  //     // Iterate over sets of three coordinates(representing verticies)]\n  //     for (let i = 0; i < array.length; i += 3) {\n  //       const x = array[i];\n  //       const y = array[i + 1];\n  //       const z = array[i + 2];\n\n  //       // Multiply Math.random value to increase randomness\n  //       array[i] = x + (Math.random() - 0.5) * 3;\n  //       array[i + 1] = y + (Math.random() - 0.5) * 3;\n  //       // + 2 allows us to access the z coordinate\n  //       array[i + 2] = z + (Math.random() - 0.5) * 4;\n\n  //       // to push in 3x the random values for each vertices\n  //       for (let i = 0; i < 3; i++) {\n  //         // multiplying by 2pi gives full range of input to sine and cosine\n  //         randomValues.push(Math.random() * Math.PI * 2);\n  //       }\n  //     }\n\n  //     // Set array of random numbers as property value\n  //     planeMesh.geometry.attributes.position.randomValues = randomValues;\n  //     // Making new property to track the original coordinates of vertices\n  //     planeMesh.geometry.attributes.position.originalPosition =\n  //       planeMesh.geometry.attributes.position.array;\n\n  //     // const { array } = planeMesh.geometry.attributes.position;\n  //     // // Iterate over sets of three coordinates(representing verticies)\n  //     // for (let i = 0; i < array.length; i += 3) {\n  //     //   const x = array[i];\n  //     //   const y = array[i + 1];\n  //     //   const z = array[i + 2];\n\n  //     //   // + 2 allows us to access the z coordinate\n  //     //   array[i + 2] = z + Math.random();\n  //     // }\n\n  //     const colors = [];\n  //     for (let i = 0; i < planeMesh.geometry.attributes.position.count; i++) {\n  //       colors.push(0, 0.19, 0.4);\n  //     }\n\n  //     // BufferAttribute must take Float32\n  //     planeMesh.geometry.setAttribute(\n  //       \"color\",\n  //       new BufferAttribute(new Float32Array(colors), 3)\n  //     );\n  //   }\n\n  //   //? Determine whether a laser would hit the object\n  //   const raycaster = new Raycaster();\n  //   // The 3D environment\n  //   const scene = new Scene();\n  //   // Determines the position from which the user \"sees\"\n  //   const camera = new PerspectiveCamera(\n  //     75,\n  //     innerWidth / innerHeight,\n  //     0.1,\n  //     1000\n  //   );\n  //   // Converts 3D to 2D via calculations\n  //   const renderer = new WebGLRenderer();\n\n  //   renderer.setSize(innerWidth, innerHeight);\n\n  //   // To remove the jagged edges of our shapes\n  //   renderer.setPixelRatio(devicePixelRatio);\n  //   document.body.appendChild(renderer.domElement);\n\n  //   new OrbitControls(camera, renderer.domElement);\n\n  //   // Can be thought of as a wireframe\n  //   const boxGeometry = new BoxGeometry(1, 1, 1);\n\n  //   // Material is basically the texture that fills up geometry\n  //   const material = new MeshBasicMaterial({ color: 0x12ff91 });\n\n  //   // Must pass in geometry and material to create a mesh\n  //   const mesh = new Mesh(boxGeometry, material);\n\n  //   // Add mesh to the scene\n  //   scene.add(mesh);\n\n  //   // How far away camera is\n  //   camera.position.z = 50;\n\n  //   const planeGeometry = new PlaneGeometry(\n  //     world.plane.width,\n  //     world.plane.height,\n  //     world.plane.widthSegments,\n  //     world.plane.heightSegments\n  //   );\n  //   const planeMaterial =\n  //     new // This is invisible until we add a light to illuminate it\n  //     MeshPhongMaterial({\n  //       // Ensures that both sides of plan is seen. Default is off due to performance reasons\n  //       side: DoubleSide,\n  //       // Flat surfaces get shading applied\n  //       flatShading: true,\n  //       vertexColors: true,\n  //     });\n\n  //   const planeMesh = new Mesh(planeGeometry, planeMaterial);\n  //   scene.add(planeMesh);\n  //   generatePlane();\n\n  //   // // color attribute addition\n  //   // const colors = [];\n  //   // for (let i = 0; i < planeMesh.geometry.attributes.position.count; i++) {\n  //   //   colors.push(0, 0.19, 0.4);\n  //   // }\n\n  //   // // BufferAttribute must take Float32\n  //   // planeMesh.geometry.setAttribute(\n  //   //   \"color\",\n  //   //   new BufferAttribute(new Float32Array(colors), 3)\n  //   // );\n\n  //   const light = new DirectionalLight(0xffffff, 1);\n  //   // Where we want to place our light relative to the center of the scene. z value of 1 moves it towards us. Has big effect on shading\n  //   light.position.set(0, 1, 1);\n  //   scene.add(light);\n\n  //   const backLight = new DirectionalLight(0xffffff, 1);\n  //   backLight.position.set(0, 0, -1);\n  //   scene.add(backLight);\n\n  //   const starGeometry = new BufferGeometry();\n  //   const starMaterial = new PointsMaterial({\n  //     color: 0xffffff,\n  //   });\n\n  //   const starVerticies = [];\n  //   for (let i = 0; i < 5000; i++) {\n  //     // Random num between -1000 and 1000\n  //     const x = (Math.random() - 0.5) * 2000;\n  //     const y = (Math.random() - 0.5) * 2000;\n  //     const z = (Math.random() - 0.5) * 2000;\n  //     starVerticies.push(x, y, z);\n  //   }\n\n  //   starGeometry.setAttribute(\n  //     \"position\",\n  //     new Float32BufferAttribute(starVerticies, 3)\n  //   );\n\n  //   const stars = new Points(starGeometry, starMaterial);\n  //   scene.add(stars);\n\n  //   const mouse = {\n  //     x: undefined,\n  //     y: undefined,\n  //   };\n\n  //   // Represents how many times `animate()` is called\n  //   let frame = 0;\n  //   // Recursive\n  //   function animate() {\n  //     requestAnimationFrame(animate);\n  //     // Still need to call render function to render out our scene\n  //     renderer.render(scene, camera);\n  //     frame += 0.01;\n\n  //     // Rotate object in each coordinate\n  //     // mesh.rotation.x += 0.02\n  //     // mesh.rotation.y += 0.02\n  //     // mesh.rotation.z += 0.02\n\n  //     // Rays are coming from the camera\n  //     raycaster.setFromCamera(mouse, camera);\n\n  //     const { array, originalPosition, randomValues } =\n  //       planeMesh.geometry.attributes.position;\n  //     for (let i = 0; i < array.length; i += 3) {\n  //       // x\n  //       array[i] =\n  //         originalPosition[i] + Math.cos(frame + randomValues[i]) * 0.01;\n  //       // y\n  //       array[i + 1] =\n  //         originalPosition[i + 1] +\n  //         Math.sin(frame + randomValues[i + 1]) * 0.001;\n  //       // z\n  //       array[i + 2] =\n  //         originalPosition[i + 2] +\n  //         Math.cos(frame + randomValues[i + 2]) * 0.025;\n  //     }\n\n  //     planeMesh.geometry.attributes.position.needsUpdate = true;\n\n  //     // Represents object I'm currently hovering over\n  //     const intersects = raycaster.intersectObject(planeMesh);\n  //     if (intersects.length > 0) {\n  //       // Destructuring to give easy access to the color property\n  //       const { color } = intersects[0].object.geometry.attributes;\n  //       // RGB: setX will set R, setY will set G, etc..\n  //       // Vertice #1\n  //       color.setX(intersects[0].face.a, 0.1);\n  //       color.setY(intersects[0].face.a, 0.5);\n  //       color.setZ(intersects[0].face.a, 1);\n  //       // Vertice #2\n  //       color.setX(intersects[0].face.b, 0.1);\n  //       color.setY(intersects[0].face.b, 0.5);\n  //       color.setZ(intersects[0].face.b, 1);\n  //       // Vertice #3\n  //       color.setX(intersects[0].face.c, 0.1);\n  //       color.setY(intersects[0].face.c, 0.5);\n  //       color.setZ(intersects[0].face.c, 1);\n  //       intersects[0].object.geometry.attributes.color.needsUpdate = true;\n\n  //       // These are the three vertices that make up a face, using indices to track\n  //       // Object { a: 91, b: 102, c: 92 }\n\n  //       const initialColor = {\n  //         r: 0,\n  //         g: 0.19,\n  //         b: 0.4,\n  //       };\n  //       const hoverColor = {\n  //         r: 0.1,\n  //         g: 0.5,\n  //         b: 1,\n  //       };\n  //       // gsap for animation\n  //       gsap.to(hoverColor, {\n  //         r: initialColor.r,\n  //         g: initialColor.g,\n  //         b: initialColor.b,\n  //         onUpdate: () => {\n  //           // Need to set values within geometry for effect\n  //           color.setX(intersects[0].face.a, hoverColor.r);\n  //           color.setY(intersects[0].face.a, hoverColor.g);\n  //           color.setZ(intersects[0].face.a, hoverColor.b);\n  //           // Vertice #2\n  //           color.setX(intersects[0].face.b, hoverColor.r);\n  //           color.setY(intersects[0].face.b, hoverColor.g);\n  //           color.setZ(intersects[0].face.b, hoverColor.b);\n  //           // Vertice #3\n  //           color.setX(intersects[0].face.c, hoverColor.r);\n  //           color.setY(intersects[0].face.c, hoverColor.g);\n  //           color.setZ(intersects[0].face.c, hoverColor.b);\n  //           color.needsUpdate = true;\n  //         },\n  //       });\n  //     }\n\n  //     stars.rotation.x += 0.0015;\n  //   }\n\n  //   animate();\n\n  //   // Normalize to a 0,0 coordinate system starting from the center\n  //   addEventListener(\"mousemove\", (event) => {\n  //     mouse.x = (event.clientX - 0.5 * innerWidth) / (0.5 * innerWidth);\n  //     mouse.y = -(event.clientY - 0.5 * innerHeight) / (0.5 * innerHeight);\n  //   });\n\n  //   gsap.to(\"#tony-liao\", {\n  //     opacity: 1,\n  //     duration: 2.5,\n  //     y: 0,\n  //     ease: \"expo\",\n  //   });\n\n  //   gsap.to(\"#portfolio-description\", {\n  //     opacity: 1,\n  //     duration: 2.5,\n  //     y: 0,\n  //     delay: 0.5,\n  //     ease: \"expo\",\n  //   });\n\n  //   gsap.to(\"#my-work-btn\", {\n  //     opacity: 1,\n  //     duration: 2.5,\n  //     y: 0,\n  //     delay: 1,\n  //     ease: \"expo\",\n  //   });\n\n  //   document.getElementById(\"my-work-btn\").addEventListener(\"click\", (e) => {\n  //     // prevents link from firing\n  //     e.preventDefault;\n  //     gsap.to(\"#container--intro\", {\n  //       opacity: 0,\n  //     });\n  //     // Zoom in effect\n  //     gsap.to(camera.position, {\n  //       z: 25,\n  //       ease: \"power3.inOut\",\n  //       duration: 2,\n  //     });\n  //     // camera rotation, uses radians!\n  //     gsap.to(camera.rotation, {\n  //       x: 1.57,\n  //       ease: \"power3.inOut\",\n  //       duration: 2,\n  //     });\n  //     // Zoom in effect\n  //     gsap.to(camera.position, {\n  //       y: 1000,\n  //       ease: \"power3.in\",\n  //       duration: 1.25,\n  //       delay: 2,\n  //       onComplete: () => {\n  //         window.location = \"https://chriscourses.com/\";\n  //       },\n  //     });\n  //   });\n\n  //   addEventListener(\"resize\", () => {\n  //     camera.aspect = innerWidth / innerHeight;\n  //     // Tells threejs to apply updated aspect ration\n  //     camera.updateProjectionMatrix();\n  //     // change renderer to fit viewport\n  //     renderer.setSize(innerWidth, innerHeight);\n  //   });\n  // },\n};\n</script>\n\n<style></style>\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAqDA,MAAK,YAAU,CAyWf;;;IA5ZI,IAAG;AAAA,IACH,OAAM;AAAA;;;;;;;;;"}